<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I am thinking ...</title>
    <link>https://hdorr.github.io/</link>
    <description>Recent content on I am thinking ...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>All rights reserved - 2018</copyright>
    <lastBuildDate>Sat, 27 Jul 2019 17:02:37 +0800</lastBuildDate>
    
	<atom:link href="https://hdorr.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>FastDFS入门安装与nginx整合</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/fastdfs/fastdfs%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%B8%8Enginx%E6%95%B4%E5%90%88/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/fastdfs/fastdfs%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%B8%8Enginx%E6%95%B4%E5%90%88/</guid>
      <description>分布式文件系统fastDFS研究 什么是分布式文件系统 技术应用场景 一个网站拥有大量的视频和图片资源,并且免费提供用户去下载,文件太多如何高效存储?用户访问量大,如何提升访问速度?
分布式文件系统可以解决上述问题.
分布式文件系统解决了海量文件存储及传输访问的瓶颈问题，对海量视频的管理、对海量图片的管理等。
什么是文件系统 总结：文件系统是负责管理和存储文件的系统软件，它是操作系统和硬件驱动之间的桥梁，操作系统通过文件系统
提供的接口去存取文件，用户通过操作系统访问磁盘上的文件。如下图：
常见的文件系统：FAT16/FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等 。
什么是分布式文件系统 为什么会有分布文件系统呢？
分布式文件系统是面对互联网的需求而产生，互联网时代对海量数据如何存储？靠简单的增加硬盘的个数已经满足
不了我们的要求，因为硬盘传输速度有限但是数据在急剧增长，另外我们还要要做好数据备份、数据安全等。
采用分布式文件系统可以将多个地点的文件系统通过网络连接起来，组成一个文件系统网络，结点之间通过网络进
行通信，一台文件系统的存储和传输能力有限，我们让文件在多台计算机上存储，通过多台计算共同传输。如下
图：
好处：
1、一台计算机的文件系统处理能力扩充到多台计算机同时处理。
2、一台计算机挂了还有另外副本计算机提供数据。
3、每台计算机可以放在不同的地域，这样用户就可以就近访问，提高访问速度。
主流的分布式文件系统 1、NFS 2、GFS 1）GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。
2）master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中。
3）用户从master中获取数据元信息，从chunkserver存储数据。
3、HDFS 1）HDFS采用主从结构，一个HDFS集群由一个名称结点和若干数据结点组成。
名称结点存储数据的元信息，一个完整的数据文件分成若干块存储在数据结点。
2）客户端从名称结点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存取数据。
分布式文件服务提供商 什么是fastDFS fastDSF介绍 FastDFS是用c语言编写的一款开源的分布式文件系统，它是由淘宝资深架构师余庆编写并开源。FastDFS专为互联
网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很
容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
为什么要使用fastDFS呢？
上边介绍的NFS、GFS都是通用的分布式文件系统，通用的分布式文件系统的优点的是开发体验好，但是系统复杂
性高、性能一般，而专用的分布式文件系统虽然开发体验性差，但是系统复杂性低并且性能高。fastDFS非常适合
存储图片等那些小文件，fastDFS不对文件进行分块，所以它就没有分块合并的开销，fastDFS网络通信采用
socket，通信速度很快。
fastDSF工作原理 fastDSF架构 FastDFS架构包括 Tracker server和Storageserver。客户端请求Tracker server进行文件上传、下载，通过Tracker
server调度最终由Storage server完成文件上传和下载。
1）Tracker Tracker Server作用是负载均衡和调度，通过Tracker server在文件上传时可以根据一些策略找到Storage server提
供文件上传服务。可以将tracker称为追踪服务器或调度服务器。
FastDFS集群中的Tracker server可以有多台，Tracker server之间是相互平等关系同时提供服务，Tracker server
不存在单点故障。客户端请求Tracker server采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。
2）Storage Storage Server作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己
的文件系统而是使用操作系统的文件系统来管理文件。可以将storage称为存储服务器。
3）Storage状态收集</description>
    </item>
    
    <item>
      <title>Promise在异步调用时的使用场景</title>
      <link>https://hdorr.github.io/post/%E5%89%8D%E7%AB%AF/es6/promise%E5%9C%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E5%89%8D%E7%AB%AF/es6/promise%E5%9C%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>下面基于,前端要调用接口删除图片的环境背景下,说明为了实现删除成功图片消失,删除失败图片不会消失的实现过程` 用到ES6中的promise语法
promise异步调用** 在handleRemove方法调用删除图片的api方法，删除成功时return true，删除失败时return false;
//删除图片 handleRemove(file, fileList) { console.log(file) // alert(&#39;删除&#39;) // return true; //删除图片 courseApi.deleteCoursePic(&#39;1&#39;).then((res) =&amp;gt; { if(res.success){ this.$message.success(&#39;删除成功&#39;); return true; }else{ this.$message.error(res.message); return false; } }); },  在上边代码中将提交的课程id故意写错，按照我们预期应该是删除失败，而测试结果却是图片在页面上删除成功。
问题原因：
通过查询deleteCoursePic方法的底层代码，deleteCoursePic最终返回一个promise对象。
Promise是ES6提供的用于异步处理的对象，因为axios提交是异步提交，这里使用promise作为返回值。
Promise的使用方法如下：
Promise对象在处理过程中有三种状态：
pending：进行中
resolved：操作成功
rejected: 操作失败
Promise的构建方法如下：
const promise = new Promise(function(resolve,reject){ //...TODO... if(操作成功){ resolve(value); }else{ reject(error); } })  上边的构造方法function(resolve,reject)执行流程如下：
1）方法执行一些业务逻辑。
2）如果操作成功将Promise的状态由pending变为resolved，并将操作结果传出去
3）如果操作失败会将promise的状态由pending变为rejected，并将失败结果传出去。
上边说的操作成功将操作结果传给谁了呢？操作失败将失败结果传给谁了呢？
通过promise的then、catch来指定
promise.then(function (result) { console.log(&#39;操作成功：&#39; + result); }); promise.</description>
    </item>
    
    <item>
      <title>RabbitMQ入门 及win安装mq</title>
      <link>https://hdorr.github.io/post/rabbitmq/rabbitmq%E5%85%A5%E9%97%A8-%E5%8F%8Awin%E5%AE%89%E8%A3%85mq/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/rabbitmq/rabbitmq%E5%85%A5%E9%97%A8-%E5%8F%8Awin%E5%AE%89%E8%A3%85mq/</guid>
      <description>RabbitMQ 入门 介绍 RabbitMQ MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message
Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开
发中应用非常广泛。RabbitMQ官方地址：http://www.rabbitmq.com/
开发中消息队列通常有如下应用场景：
1、任务异步处理。
将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。
2、应用程序解耦合
MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。
市场上还有哪些消息队列？
ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。
为什么使用RabbitMQ呢？
1、使得简单，功能强大。
2、基于AMQP协议。
3、社区活跃，文档完善。
4、高并发性能好，这主要得益于Erlang语言。
5、Spring Boot默认已集成RabbitMQ
其它相关知识 AMQP是什么 ？
总结：AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，
为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务。
官方：http://www.amqp.org/
JMS是什么 ？
总结：
JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的
jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消
息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。
入门知识 RabbitMQ的工作原理 下图是RabbitMQ的基本结构：
组成部分说明如下：
 Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。
 Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。
 Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。
 Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。
 Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。
  消息发布接收流程：
&amp;mdash;&amp;ndash;发送消息&amp;mdash;&amp;ndash;
1、生产者和Broker建立TCP连接。
2、生产者和Broker建立通道。
3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
4、Exchange将消息转发到指定的Queue（队列）
&amp;mdash;-接收消息&amp;mdash;&amp;ndash;
1、消费者和Broker建立TCP连接
2、消费者和Broker建立通道
3、消费者监听指定的Queue（队列）
4、当有消息到达Queue时Broker默认将消息推送给消费者。
5、消费者接收到消息。
下载安装 下载安装 RabbitMQ由Erlang语言开发，Erlang语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（Open</description>
    </item>
    
    <item>
      <title>cms-SSI服务端包含</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-ssi%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8C%85%E5%90%AB/</guid>
      <description>SSI服务端包含技术 本节分析首页的管理方案。
1、页面内容多如何管理？
将页面拆分成一个一个的小页面，通过cms去管理这些小页面，当要更改部分页面内容时只需要更改具体某个小页
面即可。
2、页面拆出来怎么样通过web服务浏览呢？
使用web服务(例如nginx)的SSI技术，将多个子页面合并渲染输出。
3、SSI是什么？
ssi包含类似于jsp页面中的incluce指令，ssi是在web服务端将include指定 的页面包含在网页中，渲染html网页响
应给客户端 。nginx、apache等多数web容器都支持SSI指令。
ssi指令如下：
&amp;lt;!‐‐#include virtual=&amp;quot;/../....html&amp;quot;‐‐&amp;gt;  4、将首页拆分成
index.html：首页主体内容 include/header.html：头部区域 include/index_banner.html：轮播图 include/index_category.html：左侧列表导航 include/footer.html：页尾  5、在nginx虚拟主机中开通SSI
server{ listen 80; server_name www.xuecheng.com; ssi on; ssi_silent_errors on; ......  ssi的配置参数如下： ssi on： 开启ssi支持 ssi_silent_errors on：默认为offff，设置为on则在处理SSI文件出错时不
输出错误信息 ssi_types：默认为 ssi_types text/html，如果需要支持shtml（服务器执行脚本，类似于jsp）则需
要设置为ssi_types text/shtml
6、测试
去掉某个#include查看页面效果。
类似JSP中的include,把原来的页面拆分为多个小模块,目的就是更方便CMS管理这些小页面,修改起来更方便</description>
    </item>
    
    <item>
      <title>cms-Swagger接口测试</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-swagger%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-swagger%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</guid>
      <description>Swagger Swagger介绍 OpenAPI规范（OpenAPI Specifification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格
式或API定义的语言，来规范RESTful服务开发过程，目前版本是V3.0，并且已经发布并开源在github上。
（https://github.com/OAI/OpenAPI-Specifification）
Swagger是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周
期的开发。 (https://swagger.io/)
Spring Boot 可以集成Swagger，生成Swagger接口，Spring Boot是Java领域的神器，它是Spring项目下快速构建
项目的框架。
可以在代码中加上注解注释,生成一份接口文档,并且可以在线测试接口
Swagger常用注解 在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下： @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiModelProperty：用对象接收参数时，描述对 象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用 该注解忽略这个API @ApiError ：发生错误返回的信息 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 @ApiImplicitParam属性：
Swagger接口定义 修改接口工程中页面查询接口，添加Swagger注解。
@Api(value=&amp;quot;cms页面管理接口&amp;quot;,description = &amp;quot;cms页面管理接口，提供页面的增、删、改、查&amp;quot;) public interface CmsPageControllerApi { @ApiOperation(&amp;quot;分页查询页面列表&amp;quot;) @ApiImplicitParams({ @ApiImplicitParam(name=&amp;quot;page&amp;quot;,value = &amp;quot;页 码&amp;quot;,required=true,paramType=&amp;quot;path&amp;quot;,dataType=&amp;quot;int&amp;quot;), @ApiImplicitParam(name=&amp;quot;size&amp;quot;,value = &amp;quot;每页记录 数&amp;quot;,required=true,paramType=&amp;quot;path&amp;quot;,dataType=&amp;quot;int&amp;quot;) }) public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) ; }  在QueryPageRequest类中使用注解 ApiModelProperty 对属性注释：
@Data public class QueryPageRequest extends RequestData { //站点id @ApiModelProperty(&amp;quot;站点id&amp;quot;) private String siteId; //页面ID @ApiModelProperty(&amp;quot;页面ID&amp;quot;) private String pageId; //页面名称 @ApiModelProperty(&amp;quot;页面名称&amp;quot;) private String pageName; //页面别名 @ApiModelProperty(&amp;quot;页面别名&amp;quot;) private String pageAliase; //模版id @ApiModelProperty(&amp;quot;模版id&amp;quot;) private String templateId; }  Swagger接口测试 Swagger接口生成工作原理： 1、系统启动，扫描到api工程中的Swagger2Confifiguration类 2、在此类中指定了包路径com.</description>
    </item>
    
    <item>
      <title>cms-前端cms管理项目搭建</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</guid>
      <description>创建目录结构 base：存放基础组件
base/api：基础api接口
base/component：基础组件，被各各模块都使用的组件
base/router：总的路由配置，加载各模块的路由配置文件
common：工具类 mock：存放前端单元测试方法
module：存放各业务模块的页面和api方法。 下级目录以模块名命名，
下边以cms举例：  ​ cms/api：cms模块的api接口
​ cms/component：cms模块的组件
 cms/page： cms模块的页面 cms/router：cms模块的路由配置  statics：存放第三方组件的静态资源
vuex：存放vuex文件，本项目不使用
static：与src的平级目录，此目录存放静态资源
启动** 导包之后
启动文件：
1、进入 webpacktest02目录，执行npm run dev
2、使用webstorm，右键package.json文件，选择“Show npm Scripts”
打开窗口: 双击 dev。
注意：dev就是在package.json中配置的webpack dev server命令。
发现启动成功自动打开浏览器。
修改src中的任意文件内容，自动加载并刷新浏览器。</description>
    </item>
    
    <item>
      <title>cms-后端-cms介绍及nginx后端门户静态搭建</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E5%90%8E%E7%AB%AF-cms%E4%BB%8B%E7%BB%8D%E5%8F%8Anginx%E5%90%8E%E7%AB%AF%E9%97%A8%E6%88%B7%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E5%90%8E%E7%AB%AF-cms%E4%BB%8B%E7%BB%8D%E5%8F%8Anginx%E5%90%8E%E7%AB%AF%E9%97%A8%E6%88%B7%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</guid>
      <description>CMS 什么是CMS 1、CMS是什么 ？
CMS （Content Management System）即内容管理系统，不同的项目对CMS的定位不同，比如：一个在线教育网
站，有些公司认为CMS系统是对所有的课程资源进行管理，而在早期网站刚开始盛行时很多公司的业务是网站制
作，当时对CMS的定位是创建网站，即对网站的页面、图片等静态资源进行管理。
2、CMS有哪些类型？
上边也谈到每个公司对每个项目的CMS定位不同，CMS基本上分为：针对后台数据内容的管理、针对前端页面的
管理、针对样式风格的管理等 。比如：一个给企业做网站的公司，其CMS系统主要是网站页面管理及样式风格的
管理。
3、本项目CMS的定位是什么？
本项目作为一个大型的在线教育平台，对CMS系统的定位是对各各网站（子站点）页面的管理，主要管理由于运营
需要而经常变动的页面，从而实现根据运营需要快速进行页面开发、上线的需求。
静态工程搭建 1、安装Nginx
下载nginx：http://nginx.org/en/download.html
本教程下载nginx-1.14.0.zip(http://nginx.org/download/nginx-1.14.0.zip)
解压nginx-1.14.0.zip到自己的计算机，双击nginx.exe即可运行。
访问 ：http://localhost
2、导入门户工程
将课程资料中的门户工程拷贝到代码目录。
使用WebStorm打开门户工程目录，目录的结构如下，后期会根据开发的推进进行扩充。
配置虚拟主机 server{ listen 80; server_name www.xuecheng.com; //要映射的域名 ssi on; ssi_silent_errors on; location / { alias F:/teach/xcEdu/xcEduUI/xc‐ui‐pc‐static‐portal/; //自己的静态工程目录 index index.html; } }  F:/teach/xcEdu/xcEduUI/xc-ui-pc-static-portal/ 本目录即为门户的主目录。
5、配置hosts文件
本教程的开发环境使用Windows 7，修改C:\Windows\System32\drivers\etc\hosts文件
127.0.0.1 www.xuecheng.com
进入浏览器，输入http://www.xuecheng.com
CMS页面管理需求 1、这些页面的管理流程是什么？
1）创建站点：
一个网站有很多子站点，比如：学成在线有主门户、学习中心、问答系统等子站点。具体的哪个页面是归属于具体
的站点，所以要管理页面，先要管理页面所属的站点。
2）创建模板：
页面如何创建呢？比如电商网站的商品详情页面，每个页面的内容布局、板式是相同的，不同的只是内容，这个页
面的布局、板式就是页面模板，模板+数据就组成一个完整的页面，最终要创建一个页面文件需要先定义此页面的
模板，最终拿到页面的数据再结合模板就拼装成一个完整的页面。
3）创建页面：
创建页面是指填写页面的基本信息，如：页面的名称、页面的url地址等。</description>
    </item>
    
    <item>
      <title>cms-开发准备</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/</guid>
      <description>1.CMS概述 学成在线借鉴了MOOC（大型开放式网络课程，即MOOC（massive open online courses））的设计思想，是一个提供IT职业课程在线学习的平台
当前市场的在线教育模式多种多样，包括：B2C、C2C、B2B2C等业务模式，学成在线采用B2B2C业务模式，即向 企业或个人提供在线教育平台提供教学服务，老师和学生通过平台完成整个教学和学习的过程，市场上类似的平台 有：网易云课堂、腾讯课堂等，学成在线的特点是IT职业课程在线教学。
功能模块 学成在线包括门户、学习中心、教学管理中、社交系统、系统管理等功能模块。
技术架构 技术栈 开发步骤 项目是基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作并行开发，开
发步骤如下：
1、需求分析
梳理用户的需求，分析业务流程
2、接口定义
根据需求分析定义接口
3、服务端和前端并行开发
依据接口进行服务端接口开发。
前端开发用户操作界面，并请求服务端接口完成业务处理。
4、前后端集成测试
最终前端调用服务端接口完成业务。</description>
    </item>
    
    <item>
      <title>cms-接口请求规范</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E8%AF%B7%E6%B1%82%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E8%AF%B7%E6%B1%82%E8%A7%84%E8%8C%83/</guid>
      <description> Api请求及响应规范 为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。
1、get 请求时，采用key/value格式请求，SpringMVC可采用基本类型的变量接收，也可以采用对象接收。
2、Post请求时，可以提交form表单数据（application/x-www-form-urlencoded）和Json数据（Content
Type=application/json），文件等多部件类型（multipart/form-data）三种数据格式，SpringMVC接收Json数据
使用@RequestBody注解解析请求的json数据。
4、响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。
​ 本项目,统一采用成功信息,相应代码,相应结果组成,并且最终返回结果为QueryResponseResult类型
5、响应结果统一格式为json。
Api定义约束 Api定义使用SpringMVC来完成，由于此接口后期将作为微服务远程调用使用，在定义接口时有如下限制：
1、@PathVariable 统一指定参数名称，如：@PathVariable(&amp;ldquo;id&amp;rdquo;)
​ 方法内参数要使用@PathVariable来映射路径上的参数
2、@RequestParam统一指定参数名称，如： @RequestParam（&amp;rdquo;id&amp;rdquo;）
public String getDetails( @RequestParam(value=&amp;quot;param1&amp;quot;, required=true) String param1, @RequestParam(value=&amp;quot;param2&amp;quot;, required=false) String param2){ ... }  </description>
    </item>
    
    <item>
      <title>cms-服务端统一异常处理</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/cms-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>异常处理 异常处理的问题分析 从添加页面的service方法中找问题：
//添加页面 public CmsPageResult add(CmsPage cmsPage){ //校验页面是否存在，根据页面名称、站点Id、页面webpath查询 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if(cmsPage1==null){ cmsPage.setPageId(null);//添加页面主键由spring data 自动生成 cmsPageRepository.save(cmsPage); //返回结果 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,cmsPage); return cmsPageResult; } return new CmsPageResult(CommonCode.FAIL,null); }  问题：
1、上边的代码只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信
息。
2、service方法在执行过程出现异常在哪捕获？在service中需要都加try/catch，如果在controller也需要添加
try/catch，代码冗余严重且不易维护。
解决方案：
1、在Service方法中的编码顺序是先校验判断，有问题则抛出具体的异常信息，最后执行具体的业务操作，返回成
功信息。
2、在统一异常处理类中去捕获异常，无需controller捕获异常，向用户返回统一规范的响应信息。
代码模板如下：
//添加页面 public CmsPageResult add(CmsPage cmsPage){ //校验cmsPage是否为空 if(cmsPage == null){ //抛出异常，非法请求 //... } //根据页面名称查询（页面名称已在mongodb创建了唯一索引） CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); //校验页面是否存在，已存在则抛出异常 if(cmsPage1 !=null){ //抛出异常，已存在相同的页面名称 //... } cmsPage.</description>
    </item>
    
    <item>
      <title>cms01-前端-page_List页面编写与整合后端运行</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms01-%E5%89%8D%E7%AB%AF-page_list%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms01-%E5%89%8D%E7%AB%AF-page_list%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95/</guid>
      <description>在module中创建CMS页面原型 定义cms目录,创建相应接口
在page目录中创建page_list页面
在router页面中创建index.js路由组件
import Home from &#39;@/module/home/page/home.vue&#39;; import page_list from &amp;quot;../page/page_list&amp;quot;; export default [{ path: &#39;/&#39;, component: Home, name: &#39;CMS&#39;, hidden: false, children:[ {path: &#39;/cms/page/list&#39;,name:&#39;页面列表&#39;,component: page_list } ] } ]  这样在home组件中,就可以获取到路与信息,并渲染成树状列表显示
仿照home路由组件,创建cms路由默认显示,并且设置管理页面的子路由 在base工程中合并路由组件
import Vue from &#39;vue&#39;; import Router from &#39;vue-router&#39;; Vue.use(Router); // 定义路由配置 let routes = [] let concat = (router) =&amp;gt; { routes = routes.concat(router) } // // 导入路由规则 import HomeRouter from &#39;@/module/home/router&#39; import CmsRouter from &#39;@/module/cms/router&#39; // 合并路由规则 concat(HomeRouter) concat(CmsRouter) export default routes;  开发page_list.</description>
    </item>
    
    <item>
      <title>cms01-后端-网站管理页面查询接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms01-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms01-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3/</guid>
      <description>页面查询接口定义 定义模型 需求分析
在梳理完用户需求后就要去定义前后端的接口，接口定义后前端和后端就可以依据接口去开发功能了。
本次定义页面查询接口，本接口供前端请求查询页面列表，支持分页及自定义条件查询方式。
具体需求如下：
1、分页查询CmsPage 集合下的数据
2、根据站点Id、模板Id、页面别名查询页面信息
3、接口基于Http Get请求，响应Json
模型类介绍
接口的定义离不开数据模型，根据前边对需求的分析，整个页面管理模块的数据模型如下：
CmsSite：站点模型
CmsTemplate：页面模板
CmsPage：页面信息
@Data @ToString @Document(collection = &amp;quot;cms_page&amp;quot;) public class CmsPage { /** * 页面名称、别名、访问地址、类型（静态/动态）、页面模版、状态 */ //站点ID private String siteId; //页面ID @Id private String pageId; //页面名称 private String pageName; //别名 private String pageAliase; //访问地址 private String pageWebPath; //参数 private String pageParameter; //物理路径 private String pagePhysicalPath; //类型（静态/动态） private String pageType; //页面模版 private String pageTemplate; //页面静态化内容 private String pageHtml; //状态 private String pageStatus; //创建时间 private Date pageCreateTime; //模版id private String templateId; //参数列表，暂不用 private List&amp;lt;CmsPageParam&amp;gt; pageParams; //模版文件Id // private String templateFileId; //静态文件Id private String htmlFileId; //数据Url private String dataUrl; }  属性说明：</description>
    </item>
    
    <item>
      <title>cms02--后端-网站管理页面条件查询</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms02-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms02-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</guid>
      <description>页面条件查询接口 需求分析 在页面输入查询条件，查询符合条件的页面信息。
查询条件如下：
站点Id：精确匹配
模板Id：精确匹配
页面别名：模糊匹配
服务端 Dao 使用 CmsPageRepository中的findAll(Example&amp;lt;S&amp;gt; var1, Pageable var2)方法实现，无需定义。  下边测试fifindAll方法实现自定义条件查询：
//页面条件查询测试dao @Test public void testFindAllByExample() { Pageable pageable = PageRequest.of(0, 10); //创建条件匹配器,注意匹配器每返回一个引用,在创建就是一个新对象了 //可以链式调用实现多条件 ExampleMatcher exampleMatcher = ExampleMatcher.matching() //要匹配的字段,和查询方式 //contains:模糊匹配 startWith:开头匹配 等等 .withMatcher(&amp;quot;pageAliase&amp;quot;, ExampleMatcher.GenericPropertyMatchers.contains()); // .withMatcher(&amp;quot;pageAliase&amp;quot;, ExampleMatcher.GenericPropertyMatchers.startsWith()); CmsPage cmsPage = new CmsPage(); cmsPage.setPageAliase(&amp;quot;分类导航&amp;quot;); Example&amp;lt;CmsPage&amp;gt; example = Example.of(cmsPage,exampleMatcher); Page&amp;lt;CmsPage&amp;gt; all = cmsPageRepository.findAll(example, pageable); System.out.println(all); }  Service 由于前面编写了普通查询,也将封装的条件查询类QueryPageRequest也传入参数中
​ 因此,对之前的进行改造:
 定义条件查询对象Example,在定义条件值类型对象,cmsPage 由于只有页面别名为条件匹配,其他为精确匹配,因此定义ExampleMacher条件匹配器,传入匹配字段,和查询方式 使用lang3工具类公的isNotEmpty方法判断三个查询参数,存在就设置进去 在findAll方法中将example对象传入,测试</description>
    </item>
    
    <item>
      <title>cms02-前端-page_add开发与调试 </title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms02-%E5%89%8D%E7%AB%AF-page_add%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95-/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms02-%E5%89%8D%E7%AB%AF-page_add%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95-/</guid>
      <description>创建组件 页面效果 ​ 创建page_add.vue页面 配置路由 在cms模块的路由文件中配置“添加页面”的路由：
{path:&#39;/cms/page/add&#39;,name:&#39;新增页面&#39;,component: page_add,hidden:true}  注意：由于“添加页面”不需要显示为一个菜单，这里hidden设置为true隐藏菜单。 测试，在浏览器地址栏输入http://localhost:11000/#/cms/page/add
在页面列表添加“添加页面”的按钮 实际情况是用户进入页面查询列表，点击“新增页面”按钮进入新增页面窗口。 在查询按钮的旁边添加：
&amp;lt;router-link :to=&amp;quot;{path:&#39;/cms/page/add&#39;}&amp;quot; &amp;gt; &amp;lt;el-button type=&amp;quot;primary&amp;quot; size=&amp;quot;small&amp;quot;&amp;gt;新增页面&amp;lt;/el-button&amp;gt; &amp;lt;/router-link&amp;gt;  :to为点击后跳转到相应路由
说明：router-link是vue提供的路由功能，用于在页面生成路由链接，最终在html渲染后就是标签。
page_add页面 &amp;lt;!-- pageForm就是page绑定的数据对象的名称--&amp;gt; &amp;lt;el-form :model=&amp;quot;pageForm&amp;quot; label-width=&amp;quot;80px&amp;quot; &amp;gt; &amp;lt;el-form-item label=&amp;quot;所属站点&amp;quot; prop=&amp;quot;siteId&amp;quot;&amp;gt; &amp;lt;el-select v-model=&amp;quot;pageForm.siteId&amp;quot; placeholder=&amp;quot;请选择站点&amp;quot;&amp;gt; &amp;lt;el-option v-for=&amp;quot;item in siteList&amp;quot; :key=&amp;quot;item.siteId&amp;quot; :label=&amp;quot;item.siteName&amp;quot; :value=&amp;quot;item.siteId&amp;quot;&amp;gt; &amp;lt;/el-option&amp;gt; &amp;lt;/el-select&amp;gt; &amp;lt;/el-form-item&amp;gt; &amp;lt;el-form-item label=&amp;quot;选择模板&amp;quot; prop=&amp;quot;templateId&amp;quot;&amp;gt; &amp;lt;el-select v-model=&amp;quot;pageForm.templateId&amp;quot; placeholder=&amp;quot;请选择模板&amp;quot;&amp;gt; &amp;lt;el-option v-for=&amp;quot;item in templateList&amp;quot; :key=&amp;quot;item.templateId&amp;quot; :label=&amp;quot;item.templateName&amp;quot; :value=&amp;quot;item.templateId&amp;quot;&amp;gt; &amp;lt;/el-option&amp;gt; &amp;lt;/el-select&amp;gt; &amp;lt;/el-form-item&amp;gt; &amp;lt;el-form-item label=&amp;quot;页面名称&amp;quot; prop=&amp;quot;pageName&amp;quot;&amp;gt; &amp;lt;el-input v-model=&amp;quot;pageForm.pageName&amp;quot; auto-complete=&amp;quot;off&amp;quot; &amp;gt;&amp;lt;/el-input&amp;gt; &amp;lt;/el-form-item&amp;gt; &amp;lt;el-form-item label=&amp;quot;别名&amp;quot; prop=&amp;quot;pageAliase&amp;quot;&amp;gt; &amp;lt;el-input v-model=&amp;quot;pageForm.</description>
    </item>
    
    <item>
      <title>cms03--后端-网站管理新增页面接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms03-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E6%96%B0%E5%A2%9E%E9%A1%B5%E9%9D%A2%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms03-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E6%96%B0%E5%A2%9E%E9%A1%B5%E9%9D%A2%E6%8E%A5%E5%8F%A3/</guid>
      <description>新增页面接口 定义响应模型 /** * 继承通用的responseResult响应类, * 在构造方法中添加模型类参数 */ @Data public class CmsPageResult extends ResponseResult { CmsPage cmsPage; public CmsPageResult(ResultCode resultCode,CmsPage cmsPage) { super(resultCode); this.cmsPage = cmsPage; } }  加上CmsPage参数是因为前端可能或使用到返回的数据对象
定义Api接口 /** * 新增页面 */ @ApiOperation(&amp;quot;新增页面接口&amp;quot;) public CmsPageResult addPage(CmsPage cmsPage);  Service /** * 页面新增 * @param cmsPage * @return */ public CmsPageResult addPage(CmsPage cmsPage) { //校验页面名称,webPath,页面名称唯一性 //根据上述去页面查询集合,查到就说明已存在,查询不到就可以添加 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if (cmsPage1 == null) { //调用dao,新增页面 /** * 这里因为cms_page页面pageId为主键,所以避免人为设置, * 不管有没有都将其置为空,让mongoDB的自增长自动生成主键 */ cmsPage.</description>
    </item>
    
    <item>
      <title>cms03-前端-page_edit开发与调试  </title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms03-%E5%89%8D%E7%AB%AF-page_edit%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95-/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms03-%E5%89%8D%E7%AB%AF-page_edit%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95-/</guid>
      <description>修改页面前端开发 修改页面用户操作流程：
1、用户进入修改页面，在页面上显示了修改页面的信息
2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败”
页面处理流程 页面的处理流程如下：
1、进入页面，通过钩子方法请求服务端获取页面信息，并赋值给数据模型对象
2、页面信息通过数据绑定在表单显示
3、用户修改信息点击“提交”请求服务端修改页面信息接口
编写page_edit页面 修改页面的布局同添加页面，可以直接复制添加页面，在添加页面基础上修改。
下边编写页面内容：
1、编写page_edit.vue
页面布局同添加页面，略。
2、配置路由
进入修改页面传入pageId
import page_edit from &#39;@/module/cms/page/page_edit.vue&#39;; { path: &#39;/cms/page/edit/:pageId&#39;, name:&#39;修改页面&#39;,component: page_edit,hidden:true},  3、在页面列表添加“编辑”链接 参考table组件的例子，在page_list.vue上添加“操作”列
&amp;lt;!-- 操作列,跳转到修改界面--&amp;gt; &amp;lt;el-table-column label=&amp;quot;操作&amp;quot; width=&amp;quot;80&amp;quot;&amp;gt; &amp;lt;!--slot-scope:插槽,取得当前行数据,命名为page 拿到行数据,从行中取出pageid--&amp;gt; &amp;lt;template slot-scope=&amp;quot;page&amp;quot;&amp;gt; &amp;lt;el-button size=&amp;quot;small&amp;quot;type=&amp;quot;text&amp;quot; @click=&amp;quot;edit(page.row.pageId)&amp;quot;&amp;gt;编辑 &amp;lt;/template&amp;gt; &amp;lt;/el-table-column&amp;gt;  编写edit方法
//路由跳转 edit:function (pageId) { //打开修改页面 this.$router.push({ path:&#39;/cms/page/edit/&#39;+pageId, }) },  页面内容显示 本功能实现：进入修改页面立即显示要修改的页面信息。
1、定义api方法
export const page_get=(id) =&amp;gt; { //定义方法,请求服务端站点根据id查询接口,返回结果 return http.requestQuickGet(apiUrl + &#39;/cms/page/get/&#39; +id); } export const page_edit=(id,params) =&amp;gt; { //定义方法,请求服务端站点修改页面接口,返回结果 return http.</description>
    </item>
    
    <item>
      <title>cms04--后端-网站管理修改页面接口 </title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms04-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2%E6%8E%A5%E5%8F%A3-/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms04-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2%E6%8E%A5%E5%8F%A3-/</guid>
      <description>修改页面 修改页面用户操作流程：
1、用户进入修改页面，在页面上显示了修改页面的信息
2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败”
修改页面接口定义 /** * 根据页面id查询页面信息 */ @ApiOperation(&amp;quot;根据id查询页面接口&amp;quot;) public CmsPage findPageById(String pageId); /** * 修改页面 */ @ApiOperation(&amp;quot;修改页面接口&amp;quot;) public CmsPageResult editPage(String pageId,CmsPage cmsPage);  说明：提交数据使用post、put都可以，只是根据http方法的规范，put方法是对服务器指定资源进行修改，所以这里使用put方法对页面修改进行修改。
修改页面服务端开发 Dao 使用 Spring Data提供的fifindById方法完成根据主键查询 。
使用 Spring Data提供的save方法完成数据保存 。
Service /** * 根据id查询页面 * @param pageId * @return */ public CmsPage findPageById(String pageId) { Optional&amp;lt;CmsPage&amp;gt; optional = cmsPageRepository.findById(pageId); if (optional.isPresent()) { CmsPage cmsPage = optional.get(); return cmsPage; } return null; } /** * 修改页面 * @param pageId * @param cmsPage * @return */ public CmsPageResult editPage(String pageId, CmsPage cmsPage) { // 调用方法查询是否存在 CmsPage pageById = this.</description>
    </item>
    
    <item>
      <title>cms04-前端-删除页面开发与调试 </title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms04-%E5%89%8D%E7%AB%AF-%E5%88%A0%E9%99%A4%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%89%8D%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF/cms04-%E5%89%8D%E7%AB%AF-%E5%88%A0%E9%99%A4%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95/</guid>
      <description> 删除页面前端开发 Api方法 /*页面删除*/ export const page_del = id =&amp;gt; { return http.requestDelete(apiUrl+&#39;/cms/page/del/&#39;+id) }  编写页面 1、在page_list.vue页面添加删除按钮
&amp;lt;el-table-column label=&amp;quot;操作&amp;quot; width=&amp;quot;80&amp;quot;&amp;gt; &amp;lt;!--slot-scope:插槽,取得当前行数据,命名为page 拿到行数据,从行中取出pageid--&amp;gt; &amp;lt;template slot-scope=&amp;quot;page&amp;quot;&amp;gt; &amp;lt;el-button size=&amp;quot;small&amp;quot;type=&amp;quot;text&amp;quot; @click=&amp;quot;edit(page.row.pageId)&amp;quot;&amp;gt;编辑 &amp;lt;/el-button&amp;gt; &amp;lt;el-button size=&amp;quot;small&amp;quot;type=&amp;quot;text&amp;quot; @click=&amp;quot;del(page.row.pageId)&amp;quot;&amp;gt;删除 &amp;lt;/el-button&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/el-table-column&amp;gt;  在原来,修改页面按钮的插槽中直接再加一个按钮
删除事件 del:function (pageId) { //调用接口 this.$confirm(&#39;确认删除吗？&#39;, &#39;提示&#39;, {}).then(() =&amp;gt; { cmsApi.page_del(pageId).then(res=&amp;gt;{ if (res.success) { this.$message.success(&amp;quot;删除成功&amp;quot;) //刷新页面 this.query() }else { this.$message.success(&amp;quot;删除失败&amp;quot;) } }); }) } },  </description>
    </item>
    
    <item>
      <title>cms05--后端-网站管理删除页面接口  </title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms05-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E5%88%A0%E9%99%A4%E9%A1%B5%E9%9D%A2%E6%8E%A5%E5%8F%A3-/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/1.cms%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/cms05-%E5%90%8E%E7%AB%AF-%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E5%88%A0%E9%99%A4%E9%A1%B5%E9%9D%A2%E6%8E%A5%E5%8F%A3-/</guid>
      <description> 删除页面 用户操作流程：
1、用户进入用户列表，点击“删除”
2、执行删除操作，提示“删除成功”或“删除失败”
删除页面接口定义 @ApiOperation(&amp;quot;通过ID删除页面&amp;quot;) public ResponseResult delete(String id);  删除页面服务端开发 Dao 使用 Spring Data提供的deleteById方法完成删除操作 。
Service //删除页面 public ResponseResult delete(String id){ CmsPage one = this.getById(id); if(one!=null){ //删除页面 cmsPageRepository.deleteById(id); return new ResponseResult(CommonCode.SUCCESS); } return new ResponseResult(CommonCode.FAIL); }  Controller @DeleteMapping(&amp;quot;/del/{id}&amp;quot;) //使用http的delete方法完成岗位操作 public ResponseResult delete(@PathVariable(&amp;quot;id&amp;quot;) String id) { return pageService.delete(id); }  </description>
    </item>
    
    <item>
      <title>freemaker快速入门</title>
      <link>https://hdorr.github.io/post/freemarker/freemaker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/freemarker/freemaker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>Freemarker研究 FreeMarker介绍 1、freemarker是一个用Java开发的模板引擎
常用的java模板引擎还有哪些？
Jsp、Freemarker、Thymeleaf 、Velocity 等。
2、模板+数据模型=输出
freemarker并不关心数据的来源，只是根据模板的内容，将数据模型在模板中显示并输出文件（通常为html，也
可以生成其它格式的文本文件）
1、数据模型
数据模型在java中可以是基本类型也可以List、Map、Pojo等复杂类型。
2、来自官方的例子：（https://freemarker.apache.org/docs/dgui_quickstart_basics.html）
数据模型：
模板：
输出：
FreeMarker快速入门 freemarker作为springmvc一种视图格式，默认情况下SpringMVC支持freemarker视图格式。
需要创建Spring Boot+Freemarker工程用于测试模板。
创建测试工程 创建一个freemarker 的测试工程专门用于freemarker的功能测试与模板的测试。
pom.xml如下
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;xc-framework-parent&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;com.xuecheng&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;relativePath&amp;gt;../xc-framework-parent/pom.xml&amp;lt;/relativePath&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;test-freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- http远程访问包--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt;  配置文件 配置application.</description>
    </item>
    
    <item>
      <title>博客书写说明</title>
      <link>https://hdorr.github.io/post/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>配置文件
[[menu.main]] name = &amp;ldquo;说明&amp;rdquo; weight = -1 identifier = &amp;ldquo;sm&amp;rdquo; url = &amp;ldquo;/tags/sm&amp;rdquo;
[[menu.main]] name = &amp;ldquo;主页&amp;rdquo; weight = -2 identifier = &amp;ldquo;blog&amp;rdquo; url = &amp;ldquo;/&amp;rdquo;
[[menu.main]] name = &amp;ldquo;前端&amp;rdquo; weight = -3 identifier = &amp;ldquo;qd&amp;rdquo; url = &amp;ldquo;/tags/qd&amp;rdquo;
[[menu.main]] name = &amp;ldquo;vue&amp;rdquo; weight = -4 identifier = &amp;ldquo;vue&amp;rdquo; url = &amp;ldquo;/tags/vue&amp;rdquo;
[[menu.main]] name = &amp;ldquo;Java基础&amp;rdquo; weight = -5 identifier = &amp;ldquo;jc&amp;rdquo; url = &amp;ldquo;/tags/jc&amp;rdquo;
[[menu.main]] name = &amp;ldquo;后端&amp;rdquo; weight = -6 identifier = &amp;ldquo;hd&amp;rdquo; url = &amp;ldquo;/tags/hd&amp;rdquo;</description>
    </item>
    
    <item>
      <title>消息队列与GridFS</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8Egridfs/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8Egridfs/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8Egridfs/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8Egridfs/</guid>
      <description>消息队列 GridFS 页面发布 需求分析 业务流程如下：
1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。
2、cms页面发布接口执行页面静态化，并将静态化页面(html文件)存储至GridFS中。
3、静态化成功后，向消息队列发送页面发布的消息。
页面发布的最终目标是将页面发布到服务器。
通过消息队列将页面发布的消息发送给各各服务器。
3、消息队列负责将消息发送给各各服务器上部署的Cms Client(Cms客户端)。
在服务器上部署Cms Client(Cms客户端)，客户端接收消息队列的通知。
4、每个接收到页面发布消息的Cms Client从GridFS获取Html页面文件，并将Html文件存储在本地服务器。
CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。
整个流程就是,基于前面的页面静态化工作之后,在进行页面预览之后,符合要求的页面需要发布到服务器端存一份,由于服务器是分布式的,所以要用到消息队列,发送消息请求发布,服务器接收到消息,从数据库中拿页面存到自己的服务器文件夹中,完成页面发布工作.
RabbitMQ研究 要实现上边页面发布的功能，有一个重要的环节就是由消息队列将页面发布的消息通知给各各服务器。
本节的教学目标是对MQ的研究：
1、理解MQ的应用场景
2、理解MQ常用的工作模式
RabbitMQ相关知识参考Rabbitmq笔记模块</description>
    </item>
    
    <item>
      <title>课程管理-course_add新增课程接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%E9%83%A8%E5%88%86/03.course_add%E6%96%B0%E5%A2%9E%E8%AF%BE%E7%A8%8B%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%E9%83%A8%E5%88%86/03.course_add%E6%96%B0%E5%A2%9E%E8%AF%BE%E7%A8%8B%E6%8E%A5%E5%8F%A3/</guid>
      <description>新增课程 需求分析 用户操作流程如下：
1、用户进入“我的课程”页面，点击“新增课程”，进入新增课程页面
2、填写课程信息，选择课程分类、课程等级、学习模式等。
3、信息填写完毕，点击“提交”，课程添加成功或课程添加失败并提示失败原因。
需要解决的是在新增页面上输入的信息：
1、课程分类
多级分类，需要方便用户去选择。
2、课程等级、学习模式等这些选项建议是可以配置的。
课程分类查询 介绍 在新增课程界面需要选择课程所属分类， 分类信息是整个项目非常重要的信息，课程即商品，分类信息设置的好
坏直接影响用户访问量。
分类信息在哪里应用？
1、首页分类导航
2、课程的归属地
添加课程时要选择课程的所属分类。
数据结构 分类表category的结构如下：
分类查询 数据格式 在添加课程时需要选择课程所属的分类，这里需要定义课程分类查询接口。
接口格式要根据前端需要的数据格式来定义，前端展示课程分类使用elemenet-ui的cascader（级联选择器）组
件。
数据格式例子如下：
[ { value: &#39;zhinan&#39;, label: &#39;指南&#39;, children: [{ value: &#39;shejiyuanze&#39;, label: &#39;设计原则&#39;, children: [{ value: &#39;yizhi&#39;, label: &#39;一致&#39; }, { value: &#39;fankui&#39;, label: &#39;反馈&#39; }, { value: &#39;xiaolv&#39;, label: &#39;效率&#39; }, { value: &#39;kekong&#39;, label: &#39;可控&#39; }] }] } ]  数据模型 1）定义category的模型</description>
    </item>
    
    <item>
      <title>课程管理-course_list我的课程接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%E9%83%A8%E5%88%86/02.course_list%E6%88%91%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%E9%83%A8%E5%88%86/02.course_list%E6%88%91%E7%9A%84%E8%AF%BE%E7%A8%8B%E6%8E%A5%E5%8F%A3/</guid>
      <description>我的课程 需求分析 课程添加完成后可通过我的课程进入课程修改页面，此页面显示我的课程列表，如下图所示，可分页查询。
上边的查询要实现分页、会存在多表关联查询，所以建议使用mybatis实现我的课程查询。
API接口 输入参数：
页码、每页显示个数、查询条件
输出结果类型：
QueryResponseResult&amp;lt;自定义类型&amp;gt;
在api工程创建course包，创建CourseControllerApi接口。
//查询课程列表 @ApiOperation(&amp;quot;查询我的课程列表&amp;quot;) public QueryResponseResult&amp;lt;CourseInfo&amp;gt; findCourseList( int page, int size, CourseListRequest courseListRequest );  课程管理服务 PageHelper PageHelper是mybatis的通用分页插件，通过mybatis的拦截器实现分页功能，拦截sql查询请求，添加分页语句，
最终实现分页查询功能。
我的课程具有分页功能，本项目使用Pagehelper实现Mybatis分页功能开发，由于本项目使用springboot开发，在
springboot上集成pagehelper（https://github.com/pagehelper/pagehelper-spring-boot）
PageHelper的使用方法及原理如下：
在调用dao的service方法中设置分页参数：PageHelper.startPage(page, size)，分页参数会设置在ThreadLocal中
PageHelper在mybatis执行sql前进行拦截，从ThreadLocal取出分页参数，修改当前执行的sql语句，添加分页
sql。
最后执行添加了分页sql的sql语句，实现分页查询。
1）添加依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  2）配置pageHelper
在application.yml中配置pageHelper操作的数据库类型：
pagehelper: helper-dialect: mysql  Dao 1）mapper 接口
CourseListRequest加上这个是为了后面如果有条件查询更方便
package com.xuecheng.manage_course.dao; import com.github.pagehelper.Page; import com.xuecheng.framework.domain.course.CourseBase; import com.xuecheng.framework.domain.course.ext.CourseInfo; import com.xuecheng.framework.domain.course.request.CourseListRequest; import org.apache.ibatis.annotations.Mapper; import org.springframework.stereotype.Component; /** * Created by Administrator.</description>
    </item>
    
    <item>
      <title>课程管理-course_market课程营销接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%E9%83%A8%E5%88%86/04.course_market%E8%AF%BE%E7%A8%8B%E8%90%A5%E9%94%80%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98%E9%83%A8%E5%88%86/04.course_market%E8%AF%BE%E7%A8%8B%E8%90%A5%E9%94%80%E6%8E%A5%E5%8F%A3/</guid>
      <description>课程营销 需求分析 课程营销信息包括课程价格、课程有效期等信息。
数据模型 课程营销信息使用course_market表存储。
数据模型如下：
package com.xuecheng.framework.domain.course; import lombok.Data; import lombok.ToString; import org.hibernate.annotations.GenericGenerator; import javax.persistence.*; import java.io.Serializable; import java.util.Date; /** * 课程营销管理实体类 * Created by admin on 2018/2/10. */ @Data @ToString @Entity @Table(name=&amp;quot;course_market&amp;quot;) @GenericGenerator(name = &amp;quot;jpa-assigned&amp;quot;, strategy = &amp;quot;assigned&amp;quot;) public class CourseMarket implements Serializable { private static final long serialVersionUID = -916357110051689486L; @Id @GeneratedValue(generator = &amp;quot;jpa-assigned&amp;quot;) @Column(length = 32) private String id; private String charge; private String valid; private String qq; private Float price; private Float price_old; // private Date expires; @Column(name = &amp;quot;start_time&amp;quot;) private Date startTime; @Column(name = &amp;quot;end_time&amp;quot;) private Date endTime; }  API 1) 查询课程营销信息</description>
    </item>
    
    <item>
      <title>课程管理-course_pic上传课程图片接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%9F%BA%E4%BA%8Efastdfs%E8%BF%9B%E8%A1%8C%E8%AF%BE%E7%A8%8B%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/05.course_pic%E4%B8%8A%E4%BC%A0%E8%AF%BE%E7%A8%8B%E5%9B%BE%E7%89%87%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%9F%BA%E4%BA%8Efastdfs%E8%BF%9B%E8%A1%8C%E8%AF%BE%E7%A8%8B%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86/05.course_pic%E4%B8%8A%E4%BC%A0%E8%AF%BE%E7%A8%8B%E5%9B%BE%E7%89%87%E6%8E%A5%E5%8F%A3/</guid>
      <description>上传图片开发 需求分析 在很多系统都有上传图片/上传文件的需求，比如：上传课程图片、上传课程资料、上传用户头像等，为了提供系 统的可重用性专门设立文件系统服务承担图片/文件的管理，文件系统服务实现对文件的上传、删除、查询等功能 进行管理。 各
各子系统不再开发上传文件的请求，各各子系统通过文件系统服务进行文件的上传、删除等操作。文件系统服务 最终会将文件存储到fastDSF文件系统中。
下图是各各子系统与文件系统服务之间的关系：
说明:上述简而言之就是,搭建好fastdfs图片服务器后,由于本项目有多个系统,每个系统都可能要使用文件上传和下载功能,但是每个系统具体的业务明细又不同,比如:课程图片只用一张,各系统可能要传递额外的一些参数
说明:上图就是上述问题的的解决办法,创建一个通用的文件上传和下载工程,实体类包含了上传文件的必要信息,以及各系统可能要传的额外数据组建一个实体类,设置通用的上传和下载方法,对外暴露接口 这样,课程管理系统可以调用通用接口上传,之后在调用方法将图片信息存到自己的数据库中供以后使用
也就是通用文件系统和其他文件系统没有关联,只是提供服务
执行流程如下：
1、管理员进入教学管理前端，点击上传图片
2、图片上传至文件系统服务，文件系统请求fastDFS上传文件
3、文件系统将文件入库，存储到文件系统服务数据库中。
4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的Url路径。
5、课程管理前端请求课程管理进行保存课程图片信息到课程数据库。
6、课程管理服务将课程图片保存在课程数据库。
创建文件系统服务工程 导入xc-service-base-fifilesystem.zip工程。
1）工程目录结构
pom.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;xc-framework-parent&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;com.xuecheng&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;relativePath&amp;gt;../xc-framework-parent/pom.xml&amp;lt;/relativePath&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;xc-service-base-filesystem&amp;lt;/artifactId&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.xuecheng&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;xc-service-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.xuecheng&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;xc-framework-model&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.xuecheng&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;xc-framework-common&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.oschina.zcx7878&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastdfs-client-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>课程管理-course_plan课程计划接口</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/01.course_plan%E8%AF%BE%E7%A8%8B%E8%AE%A1%E5%88%92%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/4.%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/01.course_plan%E8%AF%BE%E7%A8%8B%E8%AE%A1%E5%88%92%E6%8E%A5%E5%8F%A3/</guid>
      <description>课程计划 需求分析 什么是课程计划？
课程计划定义了课程的章节内容，学生通过课程计划进行在线学习，下图中右侧显示的就是课程计划。
课程计划包括两级，第一级是课程的大章节、第二级是大章节下属的小章节，每个小章节通常是一段视频，学生点
击小章节在线学习。
教学管理人员对课程计划如何管理？
功能包括：添加课程计划、删除课程计划、修改课程计划等。
课程计划查询接口 需求分析 课程计划查询是将某个课程的课程计划内容完整的显示出来，如下图所示：
左侧显示的就是课程计划，课程计划是一个树型结构，方便扩展课程计划的级别。
在上边页面中，点击“添加课程计划”即可对课程计划进行添加操作。
点击修改可对某个章节内容进行修改。
点击删除可删除某个章节。
页面原型 tree组件介绍 本功能使用element-ui 的tree组件来完成
在course_plan.vue文件中添加tree组件的代码，进行测试：
1、组件标签
&amp;lt;el-tree :data=&amp;quot;teachplanList&amp;quot; :props=&amp;quot;defaultProps&amp;quot; node-key=&amp;quot;id&amp;quot; default-expand-all :expand-on-click-node=&amp;quot;false&amp;quot; :render-content=&amp;quot;renderContent&amp;quot;&amp;gt; &amp;lt;/el-tree&amp;gt;  2、数据对象
teachplanList : [{ id: 1, pname: &#39;一级 1&#39;, children: [{ id: 4, pname: &#39;二级 1-1&#39;, children: [{ id: 9, pname: &#39;三级 1-1-1&#39; }, { id: 10, pname: &#39;三级 1-1-2&#39; }] }] }],  webstorm配置JSX 本组件用到了JSX语法，如下所示：
JSX 是Javascript和XML结合的一种格式，它是React的核心组成部分，JSX和XML语法类似，可以定义属性以及子元
素。唯一特殊的是可以用大括号来加入JavaScript表达式。遇到 HTML 标签（以 &amp;lt; 开头），就用 HTML 规则解析；</description>
    </item>
    
    <item>
      <title>课程管理介绍与环境搭建</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>课程管理 需求分析 在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提
供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。
课程管理包括如下功能需求：
1、分类管理
2、新增课程
3、修改课程
4、预览课程
5、发布课程
用户的操作流程如下：
1、进入我的课程
2、点击“添加课程”，进入添加课程界面
3、输入课程基本信息，点击提交
4、课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面
5、编辑图片
上传课程图片。
6、编辑课程营销信息
营销信息主要是设置课程的收费方式及价格。
7、编辑课程计划
添加课程计划：
环境搭建 搭建数据库环境
1) 创建数据库
课程管理使用MySQL数据库，创建课程管理数据库：xc_course。
导入xc_course.sql脚本
2) 数据表介绍
课程信息内容繁多，将课程信息分类保存在如下表中
数据表结构如下：
导入课程管理服务工程 1）持久层技术介绍：
课程管理服务使用MySQL数据库存储课程信息，持久层技术如下：
1、spring data jpa：用于表的基本CRUD。
2、mybatis：用于复杂的查询操作。
3、druid：使用阿里巴巴提供的spring boot 整合druid包druid-spring-boot-starter管理连接池。
druid-spring-boot-starter地址：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter
2）导入工程
导入资料下的“xc-service-manage-course.zip”。
注意:后端dao框架采用jpa和mybatis共同开发
,在复杂查询或面向sql较多的时候用mybatis,简单查询yongjpa更加方便
导入课程管理前端工程 课程管理属于教学管理子系统的功能，使用用户为教学机构的管理人员和老师，为保证系统的可维护性，单独创建
一个教学管理前端工程。 教学管理前端工程与系统管理前端的工程结构一样，也采用vue.js框架来实现。
从课程资料目录拷贝xc-ui-pc-teach.zip到工程，使用webstorm打开，启动工程：
注意:前端node-sass有错误,要npm rebuild node-sass重新编译一下</description>
    </item>
    
    <item>
      <title>页面发布功能</title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8Egridfs/%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8Egridfs/%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%E5%8A%9F%E8%83%BD/</guid>
      <description>页面发布 技术方案 本项目使用MQ实现页面发布的技术方案如下：
技术方案说明：
1、平台包括多个站点，页面归属不同的站点。
2、发布一个页面应将该页面发布到所属站点的服务器上。
3、每个站点服务部署cms client程序，并与交换机绑定，绑定时指定站点Id为routingKey。
指定站点id为routingKey就可以实现cms client只能接收到所属站点的页面发布消息。
4、页面发布程序向MQ发布消息时指定页面所属站点Id为routingKey，将该页面发布到它所在服务器上的cms
client。
路由模式分析如下：
发布一个页面，需发布到该页面所属的每个站点服务器，其它站点服务器不发布。
比如：发布一个门户的页面，需要发布到每个门户服务器上，而用户中心服务器则不需要发布。
所以本项目采用routing模式，用站点id作为routingKey，这样就可以匹配页面只发布到所属的站点服务器上。
页面发布流程图如下：
1、前端请求cms执行页面发布。
2、cms执行静态化程序生成html文件。
3、cms将html文件存储到GridFS中。
4、cms向MQ发送页面发布消息
5、MQ将页面发布消息通知给Cms Client
6、Cms Client从GridFS中下载html文件
7、Cms Client将html保存到所在服务器指定目录
页面发布消费方 需求分析
功能分析：
创建Cms Client工程作为页面发布消费方，将Cms Client部署在多个服务器上，它负责接收到页面发布 的消息后从 GridFS中下载文件在本地保存。
需求如下：
1、将cms Client部署在服务器，配置队列名称和站点ID。
2、cms Client连接RabbitMQ并监听各自的“页面发布队列”
3、cms Client接收页面发布队列的消息
4、根据消息中的页面id从mongodb数据库下载页面到本地
调用dao查询页面信息，获取到页面的物理路径，调用dao查询站点信息，得到站点的物理路径
页面物理路径=站点物理路径+页面物理路径+页面名称。
从GridFS查询静态文件内容，将静态文件内容保存到页面物理路径下。
创建Cms Client工程 1、创建maven工程
pom.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;xc-framework-parent&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;com.xuecheng&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;relativePath&amp;gt;../xc-framework-parent/pom.xml&amp;lt;/relativePath&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;xc-service-manage-cms-client&amp;lt;/artifactId&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>页面静态化与页面预览功能  </title>
      <link>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/2.%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E4%B8%8E%E9%A1%B5%E9%9D%A2%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sat, 27 Jul 2019 17:02:37 +0800</pubDate>
      
      <guid>https://hdorr.github.io/post/%E9%A1%B9%E7%9B%AE/cms/%E5%90%8E%E7%AB%AF/2.%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96%E4%B8%8E%E9%A1%B5%E9%9D%A2%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD/</guid>
      <description>页面静态化 页面预览 页面静态化需求 1、为什么要进行页面管理？
本项目cms系统的功能就是根据运营需要，对门户等子系统的部分页面进行管理，从而实现快速根据用户需求修改
页面内容并上线的需求。
2、如何修改页面的内容？
在开发中修改页面内容是需要人工编写html及JS文件，CMS系统是通过程序自动化的对页面内容进行修改，通过
页面静态化技术生成html页面。
3、如何对页面进行静态化？
一个页面等于模板加数据，在添加页面的时候我们选择了页面的模板。
页面静态化就是将页面模板和数据通过技术手段将二者合二为一，生成一个html网页文件。
4、页面静态化及页面发布流程图如下：
业务流程如下：
1、获取模型数据
2、制作模板
3、对页面进行静态化
4、将静态化生成的html页面存放文件系统中
5、将存放在文件系统的html文件发布到服务器
FreeMarker 研究 参考&amp;rdquo;Freemarker&amp;rdquo;相关资料
页面静态化 页面静态化流程 通过上边对FreeMarker的研究我们得出：模板+数据模型=输出，页面静态化需要准备数据模型和模板，先知道数
据模型的结构才可以编写模板，因为在模板中要引用数据模型中的数据，本节将系统讲解CMS页面数据模型获取、
模板管理及静态化的过程。
下边讨论一个问题：如何获取页面的数据模型？
CMS管理了各种页面，CMS对页面进行静态化时需要数据模型，但是CMS并不知道每个页面的数据模型的具体内
容，它只管执行静态化程序便可对页面进行静态化，所以CMS静态化程序需要通过一种通用的方法来获取数据模
型。
在编辑页面信息时指定一个DataUrl，此DataUrl便是获取数据模型的Url，它基于Http方式，CMS对页面进行静态
化时会从页面信息中读取DataUrl，通过Http远程调用的方法请求DataUrl获取数据模型。
管理员怎么知道DataUrl的内容呢？
举例说明：
此页面是轮播图页面，它的DataUrl由开发轮播图管理的程序员提供。
此页面是精品课程推荐页面，它的DataUrl由精品课程推荐的程序员提供。
此页面是课程详情页面，它的DataUrl由课程管理的程序员提供。
页面静态化流程如下图：
1、静态化程序首先读取页面获取DataUrl。
2、静态化程序远程请求DataUrl得到数据模型。
3、获取页面模板。
4、执行页面静态化。
数据模型 轮播图DataUrl接口 需求分析
CMS中有轮播图管理、精品课程推荐的功能，以轮播图管理为例说明：轮播图管理是通过可视化的操作界面由管理
员指定轮播图图片地址，最后将轮播图图片地址保存在cms_confifig集合中，下边是轮播图数据模型：
针对首页的轮播图信息、精品推荐等信息的获取统一提供一个Url供静态化程序调用，这样我们就知道了轮播图页
面、精品课程推荐页面的DataUrl，管理在页面配置中将此Url配置在页面信息中。
​ 本小节开发一个查询轮播图、精品推荐信息的接口，此接口供静态化程序调用获取数据模型。
接口定义 轮播图信息、精品推荐等信息存储在MongoDB的cms_confifig集合中。
cms_confifig有固定的数据结构，如下：
package com.xuecheng.framework.domain.cms; import lombok.Data; import lombok.ToString; import org.springframework.data.annotation.Id; import org.springframework.data.mongodb.core.mapping.Document; import java.util.List; /** * Created by admin on 2018/2/6.</description>
    </item>
    
  </channel>
</rss>