<!DOCTYPE html>
<html lang="zh-cn">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    
        <meta name="twitter:card" content="summary"/>
    



<meta name="twitter:title" content="1.8新特性-2Lambda表达式"/>
<meta name="twitter:description" content=""/>
<meta name="twitter:site" content="@"/>



  	<meta property="og:title" content="1.8新特性-2Lambda表达式 &middot; 喜欢养狗,不爱洗头!" />
  	<meta property="og:site_name" content="喜欢养狗,不爱洗头!" />
  	<meta property="og:url" content="https://hdorr.github.io/post/java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7/1.8%E6%96%B0%E7%89%B9%E6%80%A7-2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />

    
        
            <meta property="og:image" content="/images/hr1.jpg"/>
        
    

    
    <meta property="og:description" content="" />
  	<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2019-07-27T17:02:37&#43;08:00" />

    
    <meta property="article:tag" content="jc" />
    
    <meta property="article:tag" content="java高级" />
    
    <meta property="article:tag" content="jdk新特性" />
    
    

    <title>1.8新特性-2Lambda表达式 &middot; 喜欢养狗,不爱洗头!</title>

    
    <meta name="description" content="第三章 Lambda表达式 1.1 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。
面向对象的思想:
做一件事情,找一个能解决这个" />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://hdorr.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://hdorr.github.io/images/apple-touch-icon.png" />

    <link rel="stylesheet" type="text/css" href="https://hdorr.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://hdorr.github.io/css/nav.css" />

    

    
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/atom-one-light.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
        
        <script>hljs.initHighlightingOnLoad();</script>
    

    
      
          <link href="https://hdorr.github.io/index.xml" rel="alternate" type="application/rss+xml" title="喜欢养狗,不爱洗头!" />
      
      
    
    <meta name="generator" content="Hugo 0.56.0" />

    <link rel="canonical" href="https://hdorr.github.io/post/java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7/1.8%E6%96%B0%E7%89%B9%E6%80%A7-2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />

    
      
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name":  null ,
        "logo": "https://hdorr.github.io/images/h1.png"
    },
    "author": {
        "@type": "Person",
        "name":  null ,
        
        "image": {
            "@type": "ImageObject",
            "url": "https://hdorr.github.io/images/h1.png",
            "width": 250,
            "height": 250
        }, 
        
        "url": "suixinblog.cn",
        "sameAs": [
            
            
             
             
             
             
             
            
        ],
        "description": "Every man dies, not every man really lives."
        
    },
    "headline": "1.8新特性-2Lambda表达式",
    "name": "1.8新特性-2Lambda表达式",
    "wordCount":  578 ,
    "timeRequired": "PT3M",
    "inLanguage": {
      "@type": "Language",
      "alternateName": "en"
    },
    "url": "https://hdorr.github.io/post/java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7/1.8%E6%96%B0%E7%89%B9%E6%80%A7-2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
    "datePublished": "2019-07-27T17:02Z",
    "dateModified": "2019-07-27T17:02Z",
    
    "keywords": "jc, java高级, jdk新特性",
    "description": "",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://hdorr.github.io/post/java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7/1.8%E6%96%B0%E7%89%B9%E6%80%A7-2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
    }
}
    </script>
    


    

    

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        
        
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/sm">说明</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/">主页</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/jc">Java基础</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/qd">前端</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/hd">后端</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/ms">ms</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/spring">Spring&amp;SpringMVC相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/mybatis">Mybatis相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/vue">vue</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/springcloud">SpringCloud微服务相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/ext">异常处理</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/freemarker">Freemarker相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/rabbitmq">RabbitMQ相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/elasticsearch">ElasticSearch相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/fastdfs">FastDFS相关</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://hdorr.github.io/tags/xm">微服务教育网项目</a>
            </li>
        
        
    </ul>

    
    <a class="subscribe-button icon-feed" href="https://hdorr.github.io/index.xml">Subscribe</a>
    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">



<header class="main-header post-head no-cover">
  <nav class="main-nav clearfix">


  
      <a class="blog-logo" href="https://hdorr.github.io/"><img src="https://hdorr.github.io/images/h1.png" alt="Home" /></a>
  
  
      <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">Menu</span></a>
  
  </nav>
</header>



<main class="content" role="main">




  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">1.8新特性-2Lambda表达式</h1>
        <small></small>

        <section class="post-meta">
        
          <time class="post-date" datetime="2019-07-27T17:02:37&#43;08:00">
            Jul 27, 2019
          </time>
        
         
          <span class="post-tag small"><a href="https://hdorr.github.io//tags/jc/">#jc</a></span>
         
          <span class="post-tag small"><a href="https://hdorr.github.io//tags/java%E9%AB%98%E7%BA%A7/">#java高级</a></span>
         
          <span class="post-tag small"><a href="https://hdorr.github.io//tags/jdk%E6%96%B0%E7%89%B9%E6%80%A7/">#jdk新特性</a></span>
         
        </section>
    </header>

    <section class="post-content">
      

<h1 id="第三章-lambda-表达式"><strong>第三章</strong> <strong>Lambda</strong>表达式</h1>

<h2 id="1-1-函数式编程思想概述"><strong>1.1</strong> <strong>函数式编程思想概述</strong></h2>

<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>

<p><strong>面向对象的思想:</strong></p>

<p>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>

<p><strong>函数式编程思想:</strong></p>

<p>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>

<h2 id="1-2-冗余的-runnable代码"><strong>1.2</strong> <strong>冗余的</strong>Runnable代码</h2>

<p><strong>传统写法</strong></p>

<p>当需要启动一个线程去完成任务时，通常会通过 java.lang.Runnable 接口来定义任务内容，并使用</p>

<p>java.lang.Thread 类来启动该线程。代码如下：</p>

<pre><code class="language-java">public class Demo01Runnable {
public static void main(String[] args) {
// 匿名内部类
Runnable task = new Runnable() {
@Override
public void run() { // 覆盖重写抽象方法
System.out.println(&quot;多线程任务执行！&quot;);
}
};
new Thread(task).start(); // 启动线程
}
}
</code></pre>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个 Runnable 接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>

<p><strong>代码分析</strong></p>

<p>对于 Runnable 的匿名内部类用法，可以分析出几点内容：</p>

<ul>
<li><p>Thread 类需要 Runnable 接口作为参数，其中的抽象 run 方法是用来指定线程任务内容的核心；</p></li>

<li><p>为了指定 run 的方法体，<strong>不得不</strong>需要 Runnable 接口的实现类；</p></li>

<li><p>为了省去定义一个 RunnableImpl 实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</p></li>

<li><p>必须覆盖重写抽象 run 方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</p></li>

<li><p>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</p></li>
</ul>

<h2 id="1-3-编程思想转换"><strong>1.3</strong> <strong>编程思想转换</strong></h2>

<p><strong>做什么，而不是怎么做</strong></p>

<p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做 的事情是：将 run 方法体内的代码传递给 Thread 类知晓。</p>

<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达 到目的，过程与形式其实并不重要。</p>

<p><strong>生活举例</strong></p>

<p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>

<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda</strong>表达式的重量级新特性，为我们打开了新世界的大门。</p>

<h2 id="1-4-体验lambda的更优写法"><strong>1.4</strong> <strong>体验Lambda的更优写法</strong></h2>

<p>借助Java 8的全新语法，上述 Runnable 接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>

<pre><code class="language-java">public class Demo02LambdaRunnable {
public static void main(String[] args) {
new Thread(() ‐&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程
}
}
</code></pre>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>

<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>

<p><strong>匿名内部类的好处与弊端</strong></p>

<p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>

<p><strong>语义分析</strong></p>

<p>仔细分析该代码中的语义， Runnable 接口只有一个 run 方法的定义：</p>

<ul>
<li>public abstract void run();</li>
</ul>

<p>即制定了一种做事情的方案（其实就是一个函数）：</p>

<ul>
<li><p><strong>无参数</strong>：不需要任何条件即可执行该方案。</p></li>

<li><p><strong>无返回值</strong>：该方案不产生任何结果。</p></li>

<li><p><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</p></li>
</ul>

<p>同样的语义体现在 Lambda 语法中，要更加简单：</p>

<pre><code class="language-java">() ‐&gt; System.out.println(&quot;多线程任务执行！&quot;)
</code></pre>

<ul>
<li><p>前面的一对小括号即 run 方法的参数（无），代表不需要任何条件；</p></li>

<li><p>中间的一个箭头代表将前面的参数传递给后面的代码；</p></li>

<li><p>后面的输出语句即业务逻辑代码。</p></li>
</ul>

<h2 id="1-5-lambda-标准格式"><strong>1.5 Lambda</strong>标准格式</h2>

<p>Lambda省去面向对象的条条框框，格式由<strong>3</strong><strong>个部分</strong>组成：</p>

<ul>
<li><p>一些参数</p></li>

<li><p>一个箭头</p></li>

<li><p>一段代码</p></li>
</ul>

<p>Lambda表达式的<strong>标准格式</strong>为：</p>

<pre><code class="language-txt">(参数类型 参数名称) ‐&gt; { 代码语句 }
</code></pre>

<p>格式说明：</p>

<ul>
<li><p>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</p></li>

<li><p>-&gt; 是新引入的语法格式，代表指向动作。</p></li>

<li><p>大括号内的语法与传统方法体要求基本一致。</p></li>
</ul>

<h2 id="1-6-练习-使用-lambda-标准格式-无参无返回"><strong>1.6</strong> <strong>练习：使用</strong><strong>Lambda</strong><strong>标准格式（无参无返回）</strong></h2>

<p><strong>题目</strong></p>

<p>给定一个厨子 Cook 接口，内含唯一的抽象方法 makeFood ，且无参数、无返回值。如下：</p>

<pre><code class="language-java">public interface Cook {
void makeFood();
}
</code></pre>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用 invokeCook 方法，打印输出“吃饭啦！”字样：</p>

<pre><code class="language-java">public class Demo05InvokeCook {
public static void main(String[] args) {
// TODO 请在此使用Lambda【标准格式】调用invokeCook方法
}
private static void invokeCook(Cook cook) {
cook.makeFood();
}
}
</code></pre>

<p><strong>解答</strong></p>

<pre><code class="language-java">public static void main(String[] args) {
invokeCook(() ‐&gt; {
System.out.println(&quot;吃饭啦！&quot;);
});
}
</code></pre>

<p>备注：小括号代表 Cook 接口 makeFood 抽象方法的参数为空，大括号代表 makeFood 的方法体。</p>

<h2 id="1-7-lambda-的参数和返回值"><strong>1.7 Lambda</strong><strong>的参数和返回值</strong></h2>

<pre><code class="language-java">需求:
使用数组存储多个Person对象
对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序
</code></pre>

<p>下面举例演示 java.util.Comparator 接口的使用场景代码，其中的抽象方法定义为：</p>

<ul>
<li>public abstract int compare(T o1, T o2);</li>
</ul>

<p>当需要对一个对象数组进行排序时， Arrays.sort 方法需要一个 Comparator 接口实例来指定排序的规则。假设有</p>

<p>一个 Person 类，含有 String name 和 int age 两个成员变量：</p>

<pre><code class="language-java">public class Person {
private String name;
private int age;
// 省略构造器、toString方法与Getter Setter
}
</code></pre>

<p><strong>传统写法</strong>
如果使用传统的代码对 Person[] 数组进行排序，写法如下：</p>

<pre><code class="language-java">import java.util.Arrays;
import java.util.Comparator;
public class Demo06Comparator {
public static void main(String[] args) {
// 本来年龄乱序的对象数组
Person[] array = {
new Person(&quot;古力娜扎&quot;, 19),
new Person(&quot;迪丽热巴&quot;, 18),
new Person(&quot;马尔扎哈&quot;, 20) };
// 匿名内部类
Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() {
@Override
public int compare(Person o1, Person o2) {
return o1.getAge() ‐ o2.getAge();
}
};
Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例
for (Person person : array) {
System.out.println(person);
}
}
}
</code></pre>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中 Comparator 接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>

<p><strong>代码分析</strong></p>

<p>下面我们来搞清楚上述代码真正要做什么事情。</p>

<ul>
<li><p>为了排序， Arrays.sort 方法需要排序规则，即 Comparator 接口的实例，抽象方法 compare 是关键；</p></li>

<li><p>为了指定 compare 的方法体，<strong>不得不</strong>需要 Comparator 接口的实现类；</p></li>

<li><p>为了省去定义一个 ComparatorImpl 实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</p></li>

<li><p>必须覆盖重写抽象 compare 方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</p></li>

<li><p>实际上，<strong>只有参数和方法体才是关键</strong>。</p></li>
</ul>

<p><strong>Lambda</strong><strong>写法</strong></p>

<pre><code class="language-java">import java.util.Arrays;
public class Demo07ComparatorLambda {
public static void main(String[] args) {
Person[] array = {
new Person(&quot;古力娜扎&quot;, 19),
new Person(&quot;迪丽热巴&quot;, 18),
new Person(&quot;马尔扎哈&quot;, 20) };
Arrays.sort(array, (Person a, Person b) ‐&gt; {
return a.getAge() ‐ b.getAge();
});
for (Person person : array) {
System.out.println(person);
}
}
}
</code></pre>

<h2 id="1-8-练习-使用-lambda-标准格式-有参有返回"><strong>1.8</strong> <strong>练习：使用</strong><strong>Lambda</strong><strong>标准格式（有参有返回）</strong></h2>

<p><strong>题目</strong></p>

<p>给定一个计算器 Calculator 接口，内含抽象方法 calc 可以将两个int数字相加得到和值：</p>

<pre><code class="language-java">public interface Calculator {
int calc(int a, int b);
}
</code></pre>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用 invokeCalc 方法，完成120和130的相加计算：</p>

<pre><code class="language-java">public class Demo08InvokeCalc {
public static void main(String[] args) {
// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß
}
private static void invokeCalc(int a, int b, Calculator calculator) {
int result = calculator.calc(a, b);
System.out.println(&quot;结果是：&quot; + result);
}
}
</code></pre>

<p><strong>解答</strong></p>

<pre><code class="language-java">public static void main(String[] args) {
	invokeCalc(120, 130, (int a, int b) ‐&gt; {
		return a + b;
});
}
</code></pre>

<p>备注：小括号代表 Calculator 接口 calc 抽象方法的参数，大括号代表 calc 的方法体。</p>

<h2 id="1-9-lambda-省略格式"><strong>1.9 Lambda</strong><strong>省略格式</strong></h2>

<p><strong>可推导即可省略</strong>
Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可
以使用Lambda的省略写法：</p>

<pre><code class="language-java">public static void main(String[] args) {
invokeCalc(120, 130, (a, b) ‐&gt; a + b);
}
</code></pre>

<p><strong>省略规则</strong></p>

<p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>

<ol>
<li><p>小括号内参数的类型可以省略；</p></li>

<li><p>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</p></li>

<li><p>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</p></li>
</ol>

<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>

<h2 id="1-10-练习-使用-lambda-省略格式"><strong>1.10</strong> <strong>练习：使用</strong><strong>Lambda</strong><strong>省略格式</strong></h2>

<p><strong>题目</strong></p>

<p>仍然使用前文含有唯一 makeFood 抽象方法的厨子 Cook 接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用</p>

<p>invokeCook 方法，打印输出“吃饭啦！”字样：</p>

<pre><code class="language-java">public class Demo09InvokeCook {
public static void main(String[] args) {
// TODO 请在此使用Lambda【省略格式】调用invokeCook方法
}
private static void invokeCook(Cook cook) {
cook.makeFood();
}
}
</code></pre>

<p><strong>解答</strong></p>

<pre><code class="language-java">public static void main(String[] args) {
	invokeCook(() ‐&gt; System.out.println(&quot;吃饭啦！&quot;));
}
</code></pre>

<h2 id="1-11-lambda-的使用前提">1.11 Lambda**<strong>的使用前提</strong></h2>

<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：
1. 使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。
无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一
时，才可以使用Lambda。
2. 使用Lambda必须具有<strong>上下文推断</strong>。
也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。
备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>

    </section>


  <footer class="post-footer">


    








<figure class="author-image">
    <a class="img" href="https://hdorr.github.io/" style="background-image: url(/images/h1.png)"><span class="hidden">HuangRui's Picture</span></a>
</figure>


<section class="author">
  <h4><a href="https://hdorr.github.io/">HuangRui</a></h4>
  
  <p>Every man dies, not every man really lives.</p>
  
  <div class="author-meta">
    <span class="author-location icon-location">HaungRui, China</span>
    <span class="author-link icon-link"><a href="suixinblog.cn">suixinblog.cn</a></span>
  </div>
</section>




    
<section class="share">
  <h4>Share this post</h4>
  <a class="icon-twitter" style="font-size: 1.4em" href="https://twitter.com/share?text=1.8%e6%96%b0%e7%89%b9%e6%80%a7-2Lambda%e8%a1%a8%e8%be%be%e5%bc%8f&nbsp;-&nbsp;%e5%96%9c%e6%ac%a2%e5%85%bb%e7%8b%97%2c%e4%b8%8d%e7%88%b1%e6%b4%97%e5%a4%b4%21&amp;url=https%3a%2f%2fhdorr.github.io%2fpost%2fjava%25E5%259F%25BA%25E7%25A1%2580%2fjava%25E9%25AB%2598%25E7%25BA%25A7%2f07jdk1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%2f1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7-2lambda%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%2f"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
      <span class="hidden">Twitter</span>
  </a>
  <a class="icon-facebook" style="font-size: 1.4em" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fhdorr.github.io%2fpost%2fjava%25E5%259F%25BA%25E7%25A1%2580%2fjava%25E9%25AB%2598%25E7%25BA%25A7%2f07jdk1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%2f1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7-2lambda%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%2f"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
      <span class="hidden">Facebook</span>
  </a>
  <a class="icon-pinterest" style="font-size: 1.4em" href="http://pinterest.com/pin/create/button/?url=https%3a%2f%2fhdorr.github.io%2fpost%2fjava%25E5%259F%25BA%25E7%25A1%2580%2fjava%25E9%25AB%2598%25E7%25BA%25A7%2f07jdk1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%2f1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7-2lambda%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%2f&amp;description=1.8%e6%96%b0%e7%89%b9%e6%80%a7-2Lambda%e8%a1%a8%e8%be%be%e5%bc%8f"
      onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
      <span class="hidden">Pinterest</span>
  </a>
  <a class="icon-google-plus" style="font-size: 1.4em" href="https://plus.google.com/share?url=https%3a%2f%2fhdorr.github.io%2fpost%2fjava%25E5%259F%25BA%25E7%25A1%2580%2fjava%25E9%25AB%2598%25E7%25BA%25A7%2f07jdk1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%2f1.8%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7-2lambda%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%2f"
     onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
      <span class="hidden">Google+</span>
  </a>
</section>



    

<div id="disqus_thread"></div>
<script>




var disqus_config = function () {
this.page.url = "https:\/\/hdorr.github.io\/post\/java%E5%9F%BA%E7%A1%80\/java%E9%AB%98%E7%BA%A7\/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7\/1.8%E6%96%B0%E7%89%B9%E6%80%A7-2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\/";  
this.page.identifier = "https:\/\/hdorr.github.io\/post\/java%E5%9F%BA%E7%A1%80\/java%E9%AB%98%E7%BA%A7\/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7\/1.8%E6%96%B0%E7%89%B9%E6%80%A7-2lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\/"; 
};

(function() { 
var d = document, s = d.createElement('script');
s.src = 'https://HuangRui-1.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>








  </footer>
</article>

</main>


  <aside class="read-next">
  
      <a class="read-next-story" style="no-cover" href="https://hdorr.github.io/post/java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7/1.8%E6%96%B0%E7%89%B9%E6%80%A7-1%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/">
          <section class="post">
              <h2>1.8新特性-1函数式接口</h2>
              
          </section>
      </a>
  
  
      <a class="read-next-story prev" style="no-cover" href="https://hdorr.github.io/post/java%E5%9F%BA%E7%A1%80/java%E9%AB%98%E7%BA%A7/07jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7/1.8%E6%96%B0%E7%89%B9%E6%80%A7-3stream%E6%B5%81/">
          <section class="post">
              <h2>1.8新特性-3Stream流</h2>
          </section>
      </a>
  
</aside>



    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">喜欢养狗,不爱洗头!</a> All rights reserved - 2018</section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://hdorr.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://hdorr.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://hdorr.github.io/js/index.js"></script>
    
</body>
</html>

